/**\n * 通道分配引擎\n * 负责分配新通道到可用的服务实例\n */\n\nimport { Pool } from 'pg';\n\nexport interface AllocationRequest {\n  userId: string;\n  channelType: string;\n  credentials: { [key: string]: string };\n  metadata?: Record<string, any>;\n}\n\nexport interface AllocationResult {\n  success: boolean;\n  channelId?: string;\n  serviceId?: string;\n  instanceNumber?: number;\n  allocatedService?: string;\n  message: string;\n}\n\nconst pool = new Pool();\n\n/**\n * 通道分配引擎类\n */\nexport class ChannelAllocationEngine {\n  /**\n   * 分配通道给用户\n   */\n  public async allocateChannel(\n    request: AllocationRequest\n  ): Promise<AllocationResult> {\n    const client = await pool.connect();\n    try {\n      await client.query('BEGIN');\n\n      // Step 1: 验证总系统容量\n      const totalChannels = await this.getTotalChannelCount(client);\n      if (totalChannels >= 64) {\n        // 假设有8个服务实例，每个8个通道\n        await client.query('ROLLBACK');\n        return {\n          success: false,\n          message: 'System capacity exceeded: all services are full'\n        };\n      }\n\n      // Step 2: 查找有可用容量的服务\n      const availableService = await this.findAvailableService(client);\n\n      if (availableService) {\n        // Step 3a: 在现有服务中分配\n        const result = await this.allocateToService(\n          client,\n          availableService.id,\n          availableService.instance_name,\n          request\n        );\n\n        await client.query('COMMIT');\n        return result;\n      } else {\n        // Step 3b: 创建新的服务实例\n        const newService = await this.createNewService(client);\n        const result = await this.allocateToService(\n          client,\n          newService.id,\n          newService.instance_name,\n          request\n        );\n\n        await client.query('COMMIT');\n        return result;\n      }\n    } catch (error) {\n      await client.query('ROLLBACK');\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      console.error(`Channel allocation error: ${errorMsg}`);\n\n      return {\n        success: false,\n        message: `Allocation failed: ${errorMsg}`\n      };\n    } finally {\n      client.release();\n    }\n  }\n\n  /**\n   * 获取总通道数（所有服务）\n   */\n  private async getTotalChannelCount(client: any): Promise<number> {\n    const result = await client.query('SELECT COUNT(*) as count FROM channels');\n    return parseInt(result.rows[0].count, 10);\n  }\n\n  /**\n   * 查找有可用容量的服务\n   */\n  private async findAvailableService(\n    client: any\n  ): Promise<{ id: string; instance_name: string } | null> {\n    const result = await client.query(`\n      SELECT \n        s.id,\n        s.instance_name,\n        COUNT(c.id) as channel_count,\n        (s.max_channels - COUNT(c.id)) as available_slots\n      FROM services s\n      LEFT JOIN channels c ON s.id = c.service_id\n      WHERE s.status = 'active'\n      GROUP BY s.id, s.instance_name, s.max_channels\n      HAVING COUNT(c.id) < s.max_channels\n      ORDER BY available_slots DESC\n      LIMIT 1\n    `);\n\n    return result.rows.length > 0 ? result.rows[0] : null;\n  }\n\n  /**\n   * 在指定服务中分配通道\n   */\n  private async allocateToService(\n    client: any,\n    serviceId: string,\n    serviceName: string,\n    request: AllocationRequest\n  ): Promise<AllocationResult> {\n    try {\n      // 获取下一个实例编号\n      const nextInstanceNum = await this.getNextInstanceNumber(\n        client,\n        serviceId,\n        request.channelType\n      );\n\n      // 创建通道记录\n      const channelResult = await client.query(\n        `\n        INSERT INTO channels (\n          service_id, channel_type, instance_number, credentials, status\n        )\n        VALUES ($1, $2, $3, $4, 'active')\n        RETURNING id\n        `,\n        [\n          serviceId,\n          request.channelType,\n          nextInstanceNum,\n          JSON.stringify(request.credentials)\n        ]\n      );\n\n      const channelId = channelResult.rows[0].id;\n\n      // 绑定到用户\n      await client.query(\n        `\n        INSERT INTO user_channel_mappings (user_id, channel_id)\n        VALUES ($1, $2)\n        `,\n        [request.userId, channelId]\n      );\n\n      console.log(\n        `✅ Channel allocated: [${request.channelType}-${nextInstanceNum}] ` +\n        `to service [${serviceName}]`\n      );\n\n      return {\n        success: true,\n        channelId,\n        serviceId,\n        instanceNumber: nextInstanceNum,\n        allocatedService: serviceName,\n        message: `Channel allocated to ${serviceName} instance ${nextInstanceNum}`\n      };\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      throw new Error(`Failed to allocate to service: ${errorMsg}`);\n    }\n  }\n\n  /**\n   * 获取通道类型的下一个实例编号\n   */\n  private async getNextInstanceNumber(\n    client: any,\n    serviceId: string,\n    channelType: string\n  ): Promise<number> {\n    const result = await client.query(\n      `\n      SELECT MAX(instance_number) as max_num\n      FROM channels\n      WHERE service_id = $1 AND channel_type = $2\n      `,\n      [serviceId, channelType]\n    );\n\n    const maxNum = result.rows[0].max_num ? parseInt(result.rows[0].max_num, 10) : 0;\n    return maxNum + 1;\n  }\n\n  /**\n   * 创建新的服务实例\n   */\n  private async createNewService(\n    client: any\n  ): Promise<{ id: string; instance_name: string }> {\n    // 获取下一个实例名称\n    const nextInstanceName = await this.getNextInstanceName(client);\n\n    const result = await client.query(\n      `\n      INSERT INTO services (instance_name, status, max_channels)\n      VALUES ($1, 'active', 8)\n      RETURNING id, instance_name\n      `,\n      [nextInstanceName]\n    );\n\n    const service = result.rows[0];\n    console.log(`✅ Created new service instance: ${service.instance_name}`);\n    return service;\n  }\n\n  /**\n   * 获取下一个服务实例名称\n   */\n  private async getNextInstanceName(client: any): Promise<string> {\n    const result = await client.query(`\n      SELECT instance_name FROM services\n      WHERE instance_name LIKE 'cloudclawd%'\n      ORDER BY instance_name DESC\n      LIMIT 1\n    `);\n\n    if (result.rows.length === 0) {\n      return 'cloudclawd';\n    }\n\n    const lastName = result.rows[0].instance_name;\n    const match = lastName.match(/cloudclawd(\\d*)/);\n\n    if (!match || match[1] === '') {\n      return 'cloudclawd2';\n    }\n\n    const nextNum = parseInt(match[1], 10) + 1;\n    return `cloudclawd${nextNum}`;\n  }\n\n  /**\n   * 获取服务容量信息\n   */\n  public async getServiceCapacity(serviceId: string): Promise<{\n    totalChannels: number;\n    availableSlots: number;\n    isFull: boolean;\n  }> {\n    const result = await client.query(\n      `\n      SELECT \n        s.max_channels,\n        COUNT(c.id) as used_channels\n      FROM services s\n      LEFT JOIN channels c ON s.id = c.service_id\n      WHERE s.id = $1\n      GROUP BY s.id, s.max_channels\n      `,\n      [serviceId]\n    );\n\n    const data = result.rows[0];\n    const totalChannels = parseInt(data.used_channels, 10);\n    const availableSlots = data.max_channels - totalChannels;\n\n    return {\n      totalChannels,\n      availableSlots,\n      isFull: availableSlots === 0\n    };\n  }\n\n  /**\n   * 获取所有服务的容量摘要\n   */\n  public async getSystemCapacitySummary(): Promise<{\n    services: Array<{\n      serviceId: string;\n      instanceName: string;\n      totalChannels: number;\n      availableSlots: number;\n      isFull: boolean;\n    }>;\n    totalSystemCapacity: number;\n    totalUsed: number;\n    totalAvailable: number;\n  }> {\n    const result = await client.query(`\n      SELECT \n        s.id,\n        s.instance_name,\n        s.max_channels,\n        COUNT(c.id) as used_channels\n      FROM services s\n      LEFT JOIN channels c ON s.id = c.service_id\n      WHERE s.status = 'active'\n      GROUP BY s.id, s.instance_name, s.max_channels\n      ORDER BY s.instance_name\n    `);\n\n    const services = result.rows.map((row: any) => ({\n      serviceId: row.id,\n      instanceName: row.instance_name,\n      totalChannels: parseInt(row.used_channels, 10),\n      availableSlots: row.max_channels - parseInt(row.used_channels, 10),\n      isFull: parseInt(row.used_channels, 10) >= row.max_channels\n    }));\n\n    const totalUsed = services.reduce((sum, s) => sum + s.totalChannels, 0);\n    const totalSystemCapacity = services.length * 8;\n    const totalAvailable = totalSystemCapacity - totalUsed;\n\n    return {\n      services,\n      totalSystemCapacity,\n      totalUsed,\n      totalAvailable\n    };\n  }\n}\n\n// 导出全局实例\nexport const allocationEngine = new ChannelAllocationEngine();\n"