/**\n * 多通道环境变量解析器\n * 支持格式：CHANNEL_{SETTING}_{N}\n * 示例：FEISHU_APP_ID_1, FEISHU_APP_SECRET_1\n */\n\nimport * as dotenv from 'dotenv';\n\nexport interface ChannelInstance {\n  [setting: string]: string;\n}\n\nexport interface ChannelInstances {\n  [instanceNumber: number]: ChannelInstance;\n}\n\nexport interface ParsedChannels {\n  [channelType: string]: ChannelInstances;\n}\n\n/**\n * 解析多通道实例配置\n * @param channelType 通道类型 (如 'FEISHU', 'DINGTALK', 'WECOM')\n * @returns 通道实例对象 {instanceNum: {setting: value}}\n * \n * 示例:\n * parseChannelInstances('FEISHU')\n * 返回: {\n *   1: { app_id: 'cli_xxx', app_secret: 'secret_xxx' },\n *   2: { app_id: 'cli_yyy', app_secret: 'secret_yyy' }\n * }\n */\nexport function parseChannelInstances(channelType: string): ChannelInstances {\n  const instances: ChannelInstances = {};\n  const pattern = new RegExp(`^${channelType}_(.+?)_(\\\\d+)$`);\n\n  for (const [key, value] of Object.entries(process.env)) {\n    const match = key.match(pattern);\n\n    if (match) {\n      const setting = match[1].toLowerCase();\n      const instanceNum = parseInt(match[2], 10);\n\n      if (!instances[instanceNum]) {\n        instances[instanceNum] = {};\n      }\n\n      instances[instanceNum][setting] = value || '';\n    }\n  }\n\n  return instances;\n}\n\n/**\n * 解析所有通道配置\n * @returns 所有通道的实例配置\n */\nexport function parseAllChannels(): ParsedChannels {\n  const channelTypes = ['FEISHU', 'DINGTALK', 'WECOM', 'TELEGRAM', 'DISCORD', 'SLACK'];\n  const allChannels: ParsedChannels = {};\n\n  for (const channelType of channelTypes) {\n    const instances = parseChannelInstances(channelType);\n    if (Object.keys(instances).length > 0) {\n      allChannels[channelType] = instances;\n    }\n  }\n\n  return allChannels;\n}\n\n/**\n * 验证通道总数是否超过容量限制 (8个)\n * @param allChannels 所有通道配置\n * @throws Error 如果超过容量限制\n * @returns 通道统计信息\n */\nexport interface CapacityInfo {\n  total: number;\n  byType: { [key: string]: number };\n  available: number;\n  isFull: boolean;\n}\n\nexport function validateChannelCapacity(allChannels: ParsedChannels): CapacityInfo {\n  const MAX_CHANNELS = 8;\n  const byType: { [key: string]: number } = {};\n  let total = 0;\n\n  for (const [channelType, instances] of Object.entries(allChannels)) {\n    const count = Object.keys(instances).length;\n    byType[channelType] = count;\n    total += count;\n  }\n\n  if (total > MAX_CHANNELS) {\n    throw new Error(\n      `Channel capacity exceeded: ${total}/${MAX_CHANNELS}. ` +\n      `Distribution: ${JSON.stringify(byType)}`\n    );\n  }\n\n  return {\n    total,\n    byType,\n    available: MAX_CHANNELS - total,\n    isFull: total === MAX_CHANNELS\n  };\n}\n\n/**\n * 初始化所有通道\n * @returns 通道统计和配置\n */\nexport function initializeChannels(): {\n  allChannels: ParsedChannels;\n  capacity: CapacityInfo;\n} {\n  const allChannels = parseAllChannels();\n  const capacity = validateChannelCapacity(allChannels);\n\n  // 日志输出\n  console.log('✅ Channel capacity validation passed');\n  console.log(`   Total channels: ${capacity.total}/${8}`);\n  console.log(`   Distribution: ${JSON.stringify(capacity.byType)}`);\n\n  return { allChannels, capacity };\n}\n\n/**\n * 获取特定通道的配置\n * @param channelType 通道类型\n * @param instanceNumber 实例编号\n * @returns 该实例的配置对象\n */\nexport function getChannelConfig(\n  channelType: string,\n  instanceNumber: number\n): ChannelInstance | null {\n  const instances = parseChannelInstances(channelType);\n  return instances[instanceNumber] || null;\n}\n\n/**\n * 获取特定通道的所有实例数量\n */\nexport function getChannelInstanceCount(channelType: string): number {\n  const instances = parseChannelInstances(channelType);\n  return Object.keys(instances).length;\n}\n\n/**\n * 检查通道是否启用\n */\nexport function isChannelEnabled(channelType: string): boolean {\n  const enableKey = `${channelType}_ENABLED`;\n  return process.env[enableKey]?.toLowerCase() === 'true';\n}\n\n/**\n * 获取下一个可用的实例编号 (用于添加新通道)\n */\nexport function getNextInstanceNumber(channelType: string): number {\n  const instances = parseChannelInstances(channelType);\n  if (Object.keys(instances).length === 0) {\n    return 1;\n  }\n  const maxNum = Math.max(...Object.keys(instances).map(Number));\n  return maxNum + 1;\n}\n"