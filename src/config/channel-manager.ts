/**\n * é€šé“ç®¡ç†å™¨ - ç®¡ç†å¤šé€šé“å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸ\n */\n\nimport {\n  parseChannelInstances,\n  validateChannelCapacity,\n  isChannelEnabled,\n  ChannelInstances,\n  CapacityInfo\n} from './channel-parser';\n\nexport interface ChannelConfig {\n  type: string;\n  instanceNumber: number;\n  credentials: { [key: string]: string };\n  enabled: boolean;\n  initialized: boolean;\n  lastError?: string;\n}\n\nexport class ChannelManager {\n  private channels: Map<string, ChannelConfig> = new Map();\n  private capacityInfo: CapacityInfo | null = null;\n\n  /**\n   * åˆå§‹åŒ–æ‰€æœ‰é€šé“\n   */\n  public async initialize(): Promise<void> {\n    console.log('ğŸš€ Initializing channels...');\n\n    const channelTypes = ['FEISHU', 'DINGTALK', 'WECOM', 'TELEGRAM', 'DISCORD', 'SLACK'];\n\n    for (const channelType of channelTypes) {\n      if (!isChannelEnabled(channelType)) {\n        continue;\n      }\n\n      const instances = parseChannelInstances(channelType);\n\n      for (const [instanceNum, credentials] of Object.entries(instances)) {\n        const channelKey = `${channelType.toLowerCase()}_${instanceNum}`;\n\n        try {\n          const channel: ChannelConfig = {\n            type: channelType,\n            instanceNumber: parseInt(instanceNum, 10),\n            credentials,\n            enabled: true,\n            initialized: true\n          };\n\n          this.channels.set(channelKey, channel);\n          console.log(`  âœ… [${channelType}-${instanceNum}] Channel initialized successfully`);\n        } catch (error) {\n          const errorMsg = error instanceof Error ? error.message : String(error);\n          console.error(`  âŒ [${channelType}-${instanceNum}] Initialization failed: ${errorMsg}`);\n\n          this.channels.set(channelKey, {\n            type: channelType,\n            instanceNumber: parseInt(instanceNum, 10),\n            credentials,\n            enabled: false,\n            initialized: false,\n            lastError: errorMsg\n          });\n        }\n      }\n    }\n\n    // éªŒè¯å®¹é‡\n    const allChannels = this.getAllChannels();\n    const channelsByType: { [key: string]: number } = {};\n\n    for (const channel of allChannels.values()) {\n      if (!channelsByType[channel.type]) {\n        channelsByType[channel.type] = 0;\n      }\n      channelsByType[channel.type]++;\n    }\n\n    try {\n      this.capacityInfo = validateCapacityFromChannels(allChannels);\n      console.log(`\\nâœ… Channel capacity validation passed`);\n      console.log(`   Total channels: ${this.capacityInfo.total}/8`);\n      console.log(`   Distribution: ${JSON.stringify(this.capacityInfo.byType)}`);\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      console.error(`\\nâŒ Channel capacity validation failed: ${errorMsg}`);\n      throw error;\n    }\n  }\n\n  /**\n   * è·å–æ‰€æœ‰é€šé“\n   */\n  public getAllChannels(): Map<string, ChannelConfig> {\n    return this.channels;\n  }\n\n  /**\n   * è·å–ç‰¹å®šç±»å‹çš„æ‰€æœ‰å®ä¾‹\n   */\n  public getChannelsByType(type: string): ChannelConfig[] {\n    return Array.from(this.channels.values()).filter(\n      (ch) => ch.type === type.toUpperCase()\n    );\n  }\n\n  /**\n   * è·å–ç‰¹å®šé€šé“å®ä¾‹\n   */\n  public getChannel(type: string, instanceNumber: number): ChannelConfig | undefined {\n    const key = `${type.toLowerCase()}_${instanceNumber}`;\n    return this.channels.get(key);\n  }\n\n  /**\n   * è·å–å®¹é‡ä¿¡æ¯\n   */\n  public getCapacityInfo(): CapacityInfo | null {\n    return this.capacityInfo;\n  }\n\n  /**\n   * æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨å®¹é‡\n   */\n  public hasAvailableCapacity(): boolean {\n    return this.capacityInfo ? this.capacityInfo.available > 0 : false;\n  }\n\n  /**\n   * è·å–å·²åˆå§‹åŒ–çš„é€šé“æ•°\n   */\n  public getInitializedChannelCount(): number {\n    return Array.from(this.channels.values()).filter((ch) => ch.initialized).length;\n  }\n\n  /**\n   * è·å–åˆå§‹åŒ–å¤±è´¥çš„é€šé“\n   */\n  public getFailedChannels(): ChannelConfig[] {\n    return Array.from(this.channels.values()).filter((ch) => !ch.initialized);\n  }\n}\n\n/**\n * ä»é€šé“é…ç½®è®¡ç®—å®¹é‡\n */\nfunction validateCapacityFromChannels(channels: Map<string, ChannelConfig>): CapacityInfo {\n  const MAX_CHANNELS = 8;\n  const byType: { [key: string]: number } = {};\n  let total = 0;\n\n  for (const channel of channels.values()) {\n    if (!byType[channel.type]) {\n      byType[channel.type] = 0;\n    }\n    byType[channel.type]++;\n    total++;\n  }\n\n  if (total > MAX_CHANNELS) {\n    throw new Error(\n      `Channel capacity exceeded: ${total}/${MAX_CHANNELS}. ` +\n      `Distribution: ${JSON.stringify(byType)}`\n    );\n  }\n\n  return {\n    total,\n    byType,\n    available: MAX_CHANNELS - total,\n    isFull: total === MAX_CHANNELS\n  };\n}\n\n// å…¨å±€é€šé“ç®¡ç†å™¨å®ä¾‹\nexport const channelManager = new ChannelManager();\n"